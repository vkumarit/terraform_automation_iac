---
# (start of file)

# When access to azure devops pipeline job run summary not available
# Using Github Checks

trigger:
- main

variables:
  serviceConnection: 'az-classic-conn'
  containerName: 'mytfstate'
  key: 'terraform.tfstate'

  TF_LOG: ERROR
  TF_LOG_PATH: $(Pipeline.Workspace)/terraform-debug.log

pool:
  name: 'az-classic-pool'   # EC2 self-hosted agent

stages:
- stage: Deploy
  displayName: "Terraform Deploy"
  jobs:
  - job: Terraform
    displayName: "Terraform Plan & Apply"
    steps:

    # -----------------------------
    # Clean previous terraform logs
    # -----------------------------
    - script: |
        rm -f azuretf/simpletf/*.log
      displayName: "Clean previous terraform logs"

    # -----------------------------
    # Install Terraform
    # -----------------------------
    - task: TerraformInstaller@0
      inputs:
        terraformVersion: '1.14.3'

    # -----------------------------
    # Terraform Init
    # -----------------------------
    - script: |
        set -e
        terraform init -no-color
      workingDirectory: azuretf/simpletf
      displayName: "Terraform Init"
      env:
        ARM_CLIENT_SECRET: $(ARM_CLIENT_SECRET)

    # -----------------------------
    # Terraform Plan (capture logs)
    # -----------------------------
    - script: |
        set +e
        terraform plan \
          -no-color \
          -out=tfplan.binary \
          > terraform-plan.log 2>&1
        echo $? > plan.exitcode
      workingDirectory: azuretf/simpletf
      displayName: "Terraform Plan"
      env:
        ARM_CLIENT_SECRET: $(ARM_CLIENT_SECRET)

    # -----------------------------
    # Parse Terraform boxed errors → GitHub Checks
    # -----------------------------
    - script: |
        set +e

        LOG=terraform-plan.log
        FOUND=0

        awk '
          BEGIN { err=""; file=""; line="" }

          /│ Error:/ {
            err=$0
            gsub(/.*Error: /,"",err)
          }

          /on .* line [0-9]+/ {
            match($0, /on ([^ ]+) line ([0-9]+)/, m)
            file=m[1]
            line=m[2]
          }

          /╵/ {
            if (err != "") {
              if (file != "" && line != "") {
                printf "##vso[task.logissue type=error;sourcepath=%s;linenumber=%s]%s\n", file, line, err
              } else {
                printf "##vso[task.logissue type=error]%s\n", err
              }
              FOUND=1
            }
            err=""; file=""; line=""
          }

          END { if (FOUND) exit 1 }
        ' "$LOG"

        # Terraform summary (non-fatal)
        SUMMARY=$(grep -E "Plan:|No changes" terraform-plan.log | head -n 1)
        if [ -n "$SUMMARY" ]; then
          echo "##vso[task.logissue type=warning]Terraform Summary: $SUMMARY"
        fi
      workingDirectory: azuretf/simpletf
      displayName: "Terraform Plan → GitHub Checks (Parsed Errors)"

    # -----------------------------
    # Terraform Apply
    # -----------------------------
    - script: |
        set +e
        terraform apply \
          -no-color \
          -auto-approve tfplan.binary \
          > terraform-apply.log 2>&1
        echo $? > apply.exitcode
      workingDirectory: azuretf/simpletf
      displayName: "Terraform Apply"

    # -----------------------------
    # Parse Apply Errors → GitHub Checks
    # -----------------------------
    - script: |
        set +e

        LOG=terraform-apply.log
        FOUND=0

        awk '
          BEGIN { err=""; file=""; line="" }

          /│ Error:/ {
            err=$0
            gsub(/.*Error: /,"",err)
          }

          /on .* line [0-9]+/ {
            match($0, /on ([^ ]+) line ([0-9]+)/, m)
            file=m[1]
            line=m[2]
          }

          /╵/ {
            if (err != "") {
              if (file != "" && line != "") {
                printf "##vso[task.logissue type=error;sourcepath=%s;linenumber=%s]%s\n", file, line, err
              } else {
                printf "##vso[task.logissue type=error]%s\n", err
              }
              FOUND=1
            }
            err=""; file=""; line=""
          }

          END { if (FOUND) exit 1 }
        ' "$LOG"
      workingDirectory: azuretf/simpletf
      displayName: "Terraform Apply → GitHub Checks (Parsed Errors)"

    # -----------------------------
    # Publish Full Logs (Failed)
    # -----------------------------
    - task: PublishPipelineArtifact@1
      condition: failed()
      inputs:
        targetPath: azuretf/simpletf
        artifact: terraform-error-log

# (end of file)
...


# When access to azure devops pipeline jobs run summary available

#trigger:
#- main

#variables:
#  serviceConnection: 'az-classic-conn'
#  containerName: 'mytfstate'
#  key: 'terraform.tfstate'
#  #resourceGroup: 'myTFResourceGroup'

#pool:
#  name: 'az-classic-pool'  # EC2 self-hosted agent pool


############# Avoid Artifact 'tfplan' and Approval Gate - works for dev/test using '-auto-approve'

#stages:
#- stage: Deploy
#  jobs:
#  - job: Deploy
#    steps:
#    - task: TerraformInstaller@0
#      inputs:
#        terraformVersion: '1.14.3'  # Match version

#    - task: TerraformTaskV4@4
#      inputs:
#        provider: 'azurerm'
#        command: 'init'
#        workingDirectory: 'azuretf/simpletf' # since files in terraform_automation_IaC/azuretf/simpletf/
#        backendServiceArm: '$(serviceConnection)'
#        backendAzureRmResourceGroupName: 'myTFResourceGroup'
#        backendAzureRmStorageAccountName: 'prodmyapptfstate01'
#        backendAzureRmContainerName: '$(containerName)'
#        backendAzureRmKey: '$(key)'
#        environmentServiceNameAzureRM: '$(serviceConnection)'
#        #commandOptions: '-upgrade'

#    - task: TerraformTaskV4@4
#      name: TerraformPlan
#      inputs:
#        provider: 'azurerm'
#        command: 'plan'
#        workingDirectory: 'azuretf/simpletf'   # since files in terraform_automation_IaC/azuretf/simpletf/
#        environmentServiceNameAzureRM: '$(serviceConnection)'
#        commandOptions: >
#          -no-color                                           
#          -var="arm_client_secret=$(ARM_CLIENT_SECRET)"       
        
        # `-no-color` - makes logs readable outside UI
        # `-var="<arm-client-secret>"` - Can also pass secret directly

#    - task: TerraformTaskV4@4
#      inputs:
#        provider: 'azurerm'
#        command: 'apply'
#        workingDirectory: 'azuretf/simpletf'   # since files in terraform_automation_IaC/azuretf/simpletf/
#        environmentServiceNameAzureRM: '$(serviceConnection)'
#        commandOptions: >
#          -no-color
#          -auto-approve                              
          
        # `-auto-approve` - no approval required dev/stage


############ Use Artifact 'tfplan' and Approval Gate
#stages:
#- stage: Plan
#  jobs:
#  - job: Plan
#    steps:
#    - task: TerraformInstaller@0
#      inputs:
#        terraformVersion: '1.14.3'  # Match version

#    - task: TerraformTaskV4@4  # Or V2/V3 based on marketplace
#      inputs:
#        provider: 'azurerm'
#        command: 'init'
#        workingDirectory: 'azuretf/simpletf' # since files in terraform_automation_IaC/azuretf/simpletf/
#        backendServiceArm: '$(serviceConnection)'
#        backendAzureRmResourceGroupName: 'myTFResourceGroup'
#        backendAzureRmStorageAccountName: 'prodmyapptfstate01'
#        backendAzureRmContainerName: '$(containerName)'
#        backendAzureRmKey: '$(key)'
#        environmentServiceNameAzureRM: '$(serviceConnection)'

#    - task: TerraformTaskV4@4
#      inputs:
#        provider: 'azurerm'
#        command: 'plan'
#        workingDirectory: 'azuretf/simpletf'   # since files in terraform_automation_IaC/azuretf/simpletf/
#        environmentServiceNameAzureRM: '$(serviceConnection)'
#        commandOptions: '-out=tfplan'
        
    # PUBLISH plan as artifact
#    - task: PublishPipelineArtifact@1
#      inputs:
#        targetPath: 'azuretf/simpletf/tfplan'
#        artifact: 'tfplan'
#        publishLocation: 'pipeline'

####### Approval Gate - Method 1: Environments
#- stage: Apply
#  dependsOn: Plan
#  condition: succeeded()
#  jobs:
  
    # APPROVAL GATE via Environment
#  - deployment: ProductionDeployment
#    displayName: 'Deploy to Production'
#    environment: 'prod'  # Create this environment in Azure DevOps first as it triggers approval gate
#    strategy:
#      runOnce:           # standard deployment pattern
#        deploy:
#          steps:
#          - task: TerraformInstaller@0  # Reinstall for consistency
          
          # DOWNLOAD plan artifact
#          - task: DownloadPipelineArtifact@2
#            inputs:
#              buildType: 'current'
#              artifactName: 'tfplan'
#              targetPath: 'azuretf/simpletf/'
          
          # Add, format and use/continue locs with tasks for init and apply mentioned at end of file.  
                    
####### Approval Gate - Method 2: Manual Approval Check (No environments needed)
#- stage: Approval
#  dependsOn: Plan
#  condition: succeeded()
#  jobs:
#  - job: ManualApproval
#    pool: server  # Uses Azure DevOps server (no agent needed)
#    steps:
#    - task: ManualValidation@0
#      timeoutInMinutes: 4320  # 3 days timeout
#      inputs:
#        notifyUsers: |
#          you@company.com
#          team@company.com
#        instructions: |
#          **Review the Terraform Plan above carefully.**
          
#          This will deploy:
#          - Resource Group: myTFResourceGroup (Australia East)
#          - Storage Account: prodmyapptfstate01  
#          - Storage Container: mytfstate
#          - Key Vault: prodmyappkv
          
#          **Approve** to proceed with deployment.
#          **Reject** to stop pipeline.
          
#          tfplan artifact available for download.
#        onTimeout: 'reject'

#- stage: Apply
#  dependsOn: Approval
#  condition: succeeded()
#  jobs:
#  - job: Apply
#    steps:
#    - task: TerraformInstaller@0  # Reinstall for consistency
    
    # DOWNLOAD plan artifact
#    - task: DownloadPipelineArtifact@2
#      inputs:
#        buildType: 'current'
#        artifactName: 'tfplan'
#        targetPath: 'azuretf/simpletf/'

    # Add, format and use/continue locs with tasks for init and apply mentioned at end of file.

########
  
#          - task: TerraformTaskV4@4
#            inputs:
#              provider: 'azurerm'
#              command: 'init'
#              workingDirectory: 'azuretf/simpletf'  # since files in terraform_automation_IaC/azuretf/simpletf/
#              backendServiceArm: '$(serviceConnection)'
#              backendAzureRmResourceGroupName: 'myTFResourceGroup'
#              backendAzureRmStorageAccountName: 'prodmyapptfstate01'
#              backendAzureRmContainerName: '$(containerName)'
#              backendAzureRmKey: '$(key)'
#              environmentServiceNameAzureRM: '$(serviceConnection)'

#          - task: TerraformTaskV4@4
#            inputs:
#              provider: 'azurerm'
#              command: 'apply'
#              workingDirectory: 'azuretf/simpletf'   # since files in terraform_automation_IaC/azuretf/simpletf/
#              environmentServiceNameAzureRM: '$(serviceConnection)'
#              commandOptions: 'tfplan'
