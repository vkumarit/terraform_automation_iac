---
# (start of file)

# When access to azure devops pipeline job run summary not available
# Using Github Checks

trigger:
- main

variables:
  serviceConnection: 'az-classic-conn'
  containerName: 'mytfstate'
  key: 'terraform.tfstate'

  TF_LOG: ERROR
  TF_LOG_PATH: $(Pipeline.Workspace)/terraform-debug.log
  GITHUB_TOKEN: $(GITHUB_TOKEN)   # GitHub PAT stored as secret in pipeline

pool:
  name: 'az-classic-pool'   # EC2 self-hosted agent

stages:
- stage: Deploy
  displayName: "Terraform Deploy"
  jobs:
  - job: Terraform
    displayName: "Terraform Init, Plan & Apply"
    steps:

    # -----------------------------
    # Clean previous terraform logs
    # -----------------------------
    - script: |
        rm -f azuretf/simpletf/*.log
      displayName: "Clean previous terraform logs"

    # -----------------------------
    # Install Terraform
    # -----------------------------
    - task: TerraformInstaller@0
      inputs:
        terraformVersion: '1.14.3'

    # -----------------------------
    # Reusable script to run Terraform + GitHub Checks
    # -----------------------------
    - script: |
        #!/bin/bash
        set -euo pipefail

        REPO="your-org/your-repo"  # Change this
        COMMIT_SHA=$(git rev-parse HEAD)
        TOKEN="${GITHUB_TOKEN}"
        COMMAND=$1          # init / plan / apply
        LOG_FILE="terraform-${COMMAND}.log"

        # Run Terraform command
        if [[ "$COMMAND" == "plan" ]]; then
          terraform plan -no-color -out=tfplan.binary > "$LOG_FILE" 2>&1
        elif [[ "$COMMAND" == "apply" ]]; then
          terraform apply -no-color -auto-approve tfplan.binary > "$LOG_FILE" 2>&1
        else
          terraform init -no-color > "$LOG_FILE" 2>&1
        fi

        # Create GitHub check run
        CHECK_RUN_ID=$(curl -s -X POST "https://api.github.com/repos/${REPO}/check-runs" \
          -H "Authorization: Bearer ${TOKEN}" \
          -H "Accept: application/vnd.github.v3+json" \
          -d @- | grep -oP '"id":\K[0-9]+') 

        echo "Created GitHub check run: $CHECK_RUN_ID"

        # Initialize annotations array
        echo "[" > annotations.json

        # Parse all errors
        awk '
        BEGIN { err=""; file=""; line="" }
        /│ Error:/ { err=$0; gsub(/.*Error: /,"",err) }
        /on .* line [0-9]+/ { match($0,/on ([^ ]+) line ([0-9]+)/,m); file=m[1]; line=m[2] }
        /╵/ {
          if(err!="") {
            printf("%s{\"path\":\"%s\",\"start_line\":%s,\"end_line\":%s,\"annotation_level\":\"failure\",\"message\":\"%s\",\"title\":\"Terraform Error\"}", (NR>1?",":""), file, line, line, err)
            NR++
          }
          err=""; file=""; line=""
        }
        END { print "" }
        ' "$LOG_FILE" >> annotations.json

        echo "]" >> annotations.json

        # Determine conclusion and summary
        if grep -q '"annotation_level":"failure"' annotations.json; then
          CONCLUSION="failure"
          SUMMARY="Terraform ${COMMAND} found errors"
        else
          CONCLUSION="success"
          if [[ "$COMMAND" == "plan" ]]; then
            SUMMARY=$(grep -E "Plan:|No changes" "$LOG_FILE" | head -n1 || echo "Terraform Plan succeeded")
          else
            SUMMARY="Terraform ${COMMAND^} succeeded"
          fi
        fi

        # Complete GitHub check run
        curl -s -X PATCH "https://api.github.com/repos/${REPO}/check-runs/${CHECK_RUN_ID}" \
          -H "Authorization: Bearer ${TOKEN}" \
          -H "Accept: application/vnd.github.v3+json" \
          -d @- <<EOF
{
  "status": "completed",
  "conclusion": "${CONCLUSION}",
  "completed_at": "$(date -Iseconds)",
  "output": {
    "title": "Terraform ${COMMAND^}",
    "summary": "${SUMMARY}",
    "annotations": $(cat annotations.json)
  }
}
EOF
      workingDirectory: azuretf/simpletf
      displayName: "Run Terraform Command → GitHub Checks"
      env:
        GITHUB_TOKEN: $(GITHUB_TOKEN)

    # -----------------------------
    # Run Init
    # -----------------------------
    - script: |
        ./RunTerraform.sh init
      workingDirectory: azuretf/simpletf
      displayName: "Terraform Init → GitHub Checks"

    # -----------------------------
    # Run Plan
    # -----------------------------
    - script: |
        ./RunTerraform.sh plan
      workingDirectory: azuretf/simpletf
      displayName: "Terraform Plan → GitHub Checks"

    # -----------------------------
    # Run Apply
    # -----------------------------
    - script: |
        ./RunTerraform.sh apply
      workingDirectory: azuretf/simpletf
      displayName: "Terraform Apply → GitHub Checks"

    # -----------------------------
    # Publish Full Logs (Failed)
    # -----------------------------
    - task: PublishPipelineArtifact@1
      condition: failed()
      inputs:
        targetPath: azuretf/simpletf
        artifact: terraform-error-log

# (end of file)
...


# When access to azure devops pipeline jobs run summary available

#trigger:
#- main

#variables:
#  serviceConnection: 'az-classic-conn'
#  containerName: 'mytfstate'
#  key: 'terraform.tfstate'
#  #resourceGroup: 'myTFResourceGroup'

#pool:
#  name: 'az-classic-pool'  # EC2 self-hosted agent pool


############# Avoid Artifact 'tfplan' and Approval Gate - works for dev/test using '-auto-approve'

#stages:
#- stage: Deploy
#  jobs:
#  - job: Deploy
#    steps:
#    - task: TerraformInstaller@0
#      inputs:
#        terraformVersion: '1.14.3'  # Match version

#    - task: TerraformTaskV4@4
#      inputs:
#        provider: 'azurerm'
#        command: 'init'
#        workingDirectory: 'azuretf/simpletf' # since files in terraform_automation_IaC/azuretf/simpletf/
#        backendServiceArm: '$(serviceConnection)'
#        backendAzureRmResourceGroupName: 'myTFResourceGroup'
#        backendAzureRmStorageAccountName: 'prodmyapptfstate01'
#        backendAzureRmContainerName: '$(containerName)'
#        backendAzureRmKey: '$(key)'
#        environmentServiceNameAzureRM: '$(serviceConnection)'
#        #commandOptions: '-upgrade'

#    - task: TerraformTaskV4@4
#      name: TerraformPlan
#      inputs:
#        provider: 'azurerm'
#        command: 'plan'
#        workingDirectory: 'azuretf/simpletf'   # since files in terraform_automation_IaC/azuretf/simpletf/
#        environmentServiceNameAzureRM: '$(serviceConnection)'
#        commandOptions: >
#          -no-color                                           
#          -var="arm_client_secret=$(ARM_CLIENT_SECRET)"       
        
        # `-no-color` - makes logs readable outside UI
        # `-var="<arm-client-secret>"` - Can also pass secret directly

#    - task: TerraformTaskV4@4
#      inputs:
#        provider: 'azurerm'
#        command: 'apply'
#        workingDirectory: 'azuretf/simpletf'   # since files in terraform_automation_IaC/azuretf/simpletf/
#        environmentServiceNameAzureRM: '$(serviceConnection)'
#        commandOptions: >
#          -no-color
#          -auto-approve                              
          
        # `-auto-approve` - no approval required dev/stage


############ Use Artifact 'tfplan' and Approval Gate
#stages:
#- stage: Plan
#  jobs:
#  - job: Plan
#    steps:
#    - task: TerraformInstaller@0
#      inputs:
#        terraformVersion: '1.14.3'  # Match version

#    - task: TerraformTaskV4@4  # Or V2/V3 based on marketplace
#      inputs:
#        provider: 'azurerm'
#        command: 'init'
#        workingDirectory: 'azuretf/simpletf' # since files in terraform_automation_IaC/azuretf/simpletf/
#        backendServiceArm: '$(serviceConnection)'
#        backendAzureRmResourceGroupName: 'myTFResourceGroup'
#        backendAzureRmStorageAccountName: 'prodmyapptfstate01'
#        backendAzureRmContainerName: '$(containerName)'
#        backendAzureRmKey: '$(key)'
#        environmentServiceNameAzureRM: '$(serviceConnection)'

#    - task: TerraformTaskV4@4
#      inputs:
#        provider: 'azurerm'
#        command: 'plan'
#        workingDirectory: 'azuretf/simpletf'   # since files in terraform_automation_IaC/azuretf/simpletf/
#        environmentServiceNameAzureRM: '$(serviceConnection)'
#        commandOptions: '-out=tfplan'
        
    # PUBLISH plan as artifact
#    - task: PublishPipelineArtifact@1
#      inputs:
#        targetPath: 'azuretf/simpletf/tfplan'
#        artifact: 'tfplan'
#        publishLocation: 'pipeline'

####### Approval Gate - Method 1: Environments
#- stage: Apply
#  dependsOn: Plan
#  condition: succeeded()
#  jobs:
  
    # APPROVAL GATE via Environment
#  - deployment: ProductionDeployment
#    displayName: 'Deploy to Production'
#    environment: 'prod'  # Create this environment in Azure DevOps first as it triggers approval gate
#    strategy:
#      runOnce:           # standard deployment pattern
#        deploy:
#          steps:
#          - task: TerraformInstaller@0  # Reinstall for consistency
          
          # DOWNLOAD plan artifact
#          - task: DownloadPipelineArtifact@2
#            inputs:
#              buildType: 'current'
#              artifactName: 'tfplan'
#              targetPath: 'azuretf/simpletf/'
          
          # Add, format and use/continue locs with tasks for init and apply mentioned at end of file.  
                    
####### Approval Gate - Method 2: Manual Approval Check (No environments needed)
#- stage: Approval
#  dependsOn: Plan
#  condition: succeeded()
#  jobs:
#  - job: ManualApproval
#    pool: server  # Uses Azure DevOps server (no agent needed)
#    steps:
#    - task: ManualValidation@0
#      timeoutInMinutes: 4320  # 3 days timeout
#      inputs:
#        notifyUsers: |
#          you@company.com
#          team@company.com
#        instructions: |
#          **Review the Terraform Plan above carefully.**
          
#          This will deploy:
#          - Resource Group: myTFResourceGroup (Australia East)
#          - Storage Account: prodmyapptfstate01  
#          - Storage Container: mytfstate
#          - Key Vault: prodmyappkv
          
#          **Approve** to proceed with deployment.
#          **Reject** to stop pipeline.
          
#          tfplan artifact available for download.
#        onTimeout: 'reject'

#- stage: Apply
#  dependsOn: Approval
#  condition: succeeded()
#  jobs:
#  - job: Apply
#    steps:
#    - task: TerraformInstaller@0  # Reinstall for consistency
    
    # DOWNLOAD plan artifact
#    - task: DownloadPipelineArtifact@2
#      inputs:
#        buildType: 'current'
#        artifactName: 'tfplan'
#        targetPath: 'azuretf/simpletf/'

    # Add, format and use/continue locs with tasks for init and apply mentioned at end of file.

########
  
#          - task: TerraformTaskV4@4
#            inputs:
#              provider: 'azurerm'
#              command: 'init'
#              workingDirectory: 'azuretf/simpletf'  # since files in terraform_automation_IaC/azuretf/simpletf/
#              backendServiceArm: '$(serviceConnection)'
#              backendAzureRmResourceGroupName: 'myTFResourceGroup'
#              backendAzureRmStorageAccountName: 'prodmyapptfstate01'
#              backendAzureRmContainerName: '$(containerName)'
#              backendAzureRmKey: '$(key)'
#              environmentServiceNameAzureRM: '$(serviceConnection)'

#          - task: TerraformTaskV4@4
#            inputs:
#              provider: 'azurerm'
#              command: 'apply'
#              workingDirectory: 'azuretf/simpletf'   # since files in terraform_automation_IaC/azuretf/simpletf/
#              environmentServiceNameAzureRM: '$(serviceConnection)'
#              commandOptions: 'tfplan'
